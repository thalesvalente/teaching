# -*- coding: utf-8 -*-
"""LFA - P2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HXbBalSBoDrqHLaJfqg9meAWdvLChwUH
"""

import graphviz

class DFA:
    def __init__(self, states, alphabet, transition_function, start_state, accept_states):
        """
        Inicializa o DFA com os estados, alfabeto, função de transição, estado inicial e estados de aceitação.
        """
        self.states = states
        self.alphabet = alphabet
        self.transition_function = transition_function
        self.start_state = start_state
        self.accept_states = accept_states

    def minimize(self):
        """
        Minimiza o DFA utilizando o algoritmo de minimização de estados.
        """
        # Passo 1: Remover estados inalcançáveis
        reachable_states = self._get_reachable_states()

        # Passo 2: Particionar estados em conjuntos de aceitação e não aceitação
        partitions = [set(self.accept_states), set(self.states) - set(self.accept_states)]

        # Passo 3: Refinar iterativamente as partições
        refined_partitions = self._refine_partitions(partitions, reachable_states)

        # Passo 4: Construir o DFA minimizado
        minimized_dfa = self._construct_minimized_dfa(refined_partitions)

        return minimized_dfa

    def _get_reachable_states(self):
        """
        Obtém os estados alcançáveis a partir do estado inicial.
        """
        reachable_states = set()
        queue = [self.start_state]
        while queue:
            state = queue.pop(0)
            if state not in reachable_states:
                reachable_states.add(state)
                for symbol in self.alphabet:
                    next_state = self.transition_function[state][symbol]
                    if next_state not in reachable_states:
                        queue.append(next_state)
        return reachable_states

    def _refine_partitions(self, partitions, reachable_states):
        """
        Refina as partições de estados iterativamente.
        """
        while True:
            new_partitions = []
            for partition in partitions:
                # Refinar a partição
                partition_map = {}
                for state in partition:
                    key = tuple(self._get_transition_partition(state, partitions))
                    if key not in partition_map:
                        partition_map[key] = set()
                    partition_map[key].add(state)

                new_partitions.extend(partition_map.values())

            # Verificar se as partições foram refinadas
            if len(new_partitions) == len(partitions):
                break
            partitions = new_partitions

        # Remover estados inalcançáveis das partições
        partitions = [partition & reachable_states for partition in partitions]
        partitions = [partition for partition in partitions if partition]

        return partitions

    def _get_transition_partition(self, state, partitions):
        """
        Obtém a partição de transição para um estado dado.
        """
        transition_partition = []
        for symbol in self.alphabet:
            next_state = self.transition_function[state][symbol]
            for i, partition in enumerate(partitions):
                if next_state in partition:
                    transition_partition.append(i)
                    break
        return transition_partition

    def _construct_minimized_dfa(self, partitions):
        """
        Constrói o DFA minimizado a partir das partições refinadas.
        """
        state_map = {state: i for i, partition in enumerate(partitions) for state in partition}
        minimized_states = list(range(len(partitions)))
        minimized_start_state = state_map[self.start_state]
        minimized_accept_states = {state_map[state] for state in self.accept_states}
        minimized_transition_function = {}

        for i, partition in enumerate(partitions):
            state = next(iter(partition))
            minimized_transition_function[i] = {}
            for symbol in self.alphabet:
                next_state = self.transition_function[state][symbol]
                minimized_transition_function[i][symbol] = state_map[next_state]

        return DFA(
            states=minimized_states,
            alphabet=self.alphabet,
            transition_function=minimized_transition_function,
            start_state=minimized_start_state,
            accept_states=minimized_accept_states
        )

    def __str__(self):
        """
        Retorna uma representação em string do DFA.
        """
        return (f"States: {self.states}\n"
                f"Alphabet: {self.alphabet}\n"
                f"Transition Function: {self.transition_function}\n"
                f"Start State: {self.start_state}\n"
                f"Accept States: {self.accept_states}")

    def plot(self, title='DFA'):
        """
        Gera uma visualização gráfica do DFA utilizando a biblioteca graphviz.
        """
        dot = graphviz.Digraph(comment=title)

        # Adicionar nós
        for state in self.states:
            if state in self.accept_states:
                dot.node(str(state), shape='doublecircle')
            else:
                dot.node(str(state), shape='circle')

        # Adicionar arestas
        for state in self.transition_function:
            for symbol in self.alphabet:
                next_state = self.transition_function[state][symbol]
                dot.edge(str(state), str(next_state), label=symbol)

        # Marcar o estado inicial
        dot.node('', shape='none', width='0', height='0')
        dot.edge('', str(self.start_state))

        return dot

# Exemplo de uso
states = {'q0', 'q1', 'q2', 'q3'}
alphabet = {'0', '1'}
transition_function = {
    'q0': {'0': 'q0', '1': 'q1'},
    'q1': {'0': 'q2', '1': 'q1'},
    'q2': {'0': 'q3', '1': 'q1'},
    'q3': {'0': 'q2', '1': 'q1'},
}
start_state = 'q0'
accept_states = {'q1'}

dfa = DFA(states, alphabet, transition_function, start_state, accept_states)
print("Original DFA:")
print(dfa)

minimized_dfa = dfa.minimize()
print("\nMinimized DFA:")
print(minimized_dfa)

# Plotar os DFAs
original_dfa_plot = dfa.plot('Original DFA')
original_dfa_plot.render('original_dfa', format='png', cleanup=True)

minimized_dfa_plot = minimized_dfa.plot('Minimized DFA')
minimized_dfa_plot.render('minimized_dfa', format='png', cleanup=True)